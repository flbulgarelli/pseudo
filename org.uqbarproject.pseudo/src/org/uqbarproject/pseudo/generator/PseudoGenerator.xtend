/*
 * generated by Xtext
 */
package org.uqbarproject.pseudo.generator

import com.google.inject.Inject
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.uqbarproject.pseudo.pseudo.Applicable
import org.uqbarproject.pseudo.pseudo.AssignExpression
import org.uqbarproject.pseudo.pseudo.Attribute
import org.uqbarproject.pseudo.pseudo.DecrementExpression
import org.uqbarproject.pseudo.pseudo.Expression
import org.uqbarproject.pseudo.pseudo.FalseExpression
import org.uqbarproject.pseudo.pseudo.IdExpression
import org.uqbarproject.pseudo.pseudo.IncrementExpression
import org.uqbarproject.pseudo.pseudo.InitExpression
import org.uqbarproject.pseudo.pseudo.ListLiteralExpression
import org.uqbarproject.pseudo.pseudo.LocalVariable
import org.uqbarproject.pseudo.pseudo.Message
import org.uqbarproject.pseudo.pseudo.MessageSendExpression
import org.uqbarproject.pseudo.pseudo.Method
import org.uqbarproject.pseudo.pseudo.NewExpression
import org.uqbarproject.pseudo.pseudo.NullExpression
import org.uqbarproject.pseudo.pseudo.NumberExpression
import org.uqbarproject.pseudo.pseudo.Parameter
import org.uqbarproject.pseudo.pseudo.Return
import org.uqbarproject.pseudo.pseudo.SelfExpression
import org.uqbarproject.pseudo.pseudo.SetLiteralExpression
import org.uqbarproject.pseudo.pseudo.SetupExpression
import org.uqbarproject.pseudo.pseudo.StringExpression
import org.uqbarproject.pseudo.pseudo.SuperSend
import org.uqbarproject.pseudo.pseudo.TrueExpression
import org.uqbarproject.pseudo.pseudo.Type
import org.uqbarproject.pseudo.pseudo.WhenExpression
import org.uqbarproject.pseudo.pseudo.ComparisonExpression
import org.uqbarproject.pseudo.pseudo.ComparisonOperation
import org.uqbarproject.pseudo.pseudo.ThrowExpression
import org.uqbarproject.pseudo.pseudo.TryCatchExpression
import org.uqbarproject.pseudo.pseudo.ReductionExpression
import org.uqbarproject.pseudo.pseudo.FilteredExpression
import org.uqbarproject.pseudo.pseudo.ForAllExpression
import org.uqbarproject.pseudo.pseudo.SelectExpression

import static extension org.uqbarproject.pseudo.SelectorExtensions.*
import static extension org.uqbarproject.pseudo.util.EObjectExtensions.*
import org.uqbarproject.pseudo.pseudo.Reduction
import org.uqbarproject.pseudo.pseudo.Sum
import org.uqbarproject.pseudo.pseudo.Average
import org.uqbarproject.pseudo.pseudo.Min
import org.uqbarproject.pseudo.pseudo.Max
import org.uqbarproject.pseudo.pseudo.All
import org.uqbarproject.pseudo.pseudo.Any

/**
 * @author flbulgareli
 */
class PseudoGenerator implements IGenerator {
	
    @Inject extension IQualifiedNameProvider
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		resource.allContents.filter(typeof(Type)).forEach [
			fsa.generateFile(
				it.fullyQualifiedName.toString("/") + ".java", 
				it.compile
			)
		]
	}
	
  	def dispatch compile(EObject declaration) { 
  		declaration.subclassResponsibility('compile') as String
  	}
	def dispatch compile(Type type) '''
		import org.uqbarproject.pseudo.runtime.*;
		import org.uqbarproject.pseudo.runtime.reductions.*;
		public class «type.name» extends «type.effectiveSuperType» {

			public «type.name»() {
			}
			«var attributesNames = type.members.filter(typeof(Attribute)).map[it.name.toJavaId]»
			«IF !attributesNames.empty»
			public «type.name»(«joinCompileParameters(attributesNames)») {
				«FOR attributeName : attributesNames»
				this.«attributeName» = «attributeName»;
				«ENDFOR»
			}		
			«ENDIF»
			
		  	«FOR member : type.members»
		  	  «member.compile»		
		  	«ENDFOR»
		  	
		  	@Override
		  	public String toString() {
		  		return "«type.name»[«type.members.filter(typeof(Attribute)).map[it.name + '="+'+it.name.toJavaId+'+"'].join(", ")»]";	
			}
		}
  	'''
  	def dispatch compile(Method method) '''
	  «IF method.overrideMethod»
	  @Override
	  «ENDIF»
	  public «method.classMethod.compileClassModifier» Object «method.name.toJavaId»(«joinCompileParameters(method.parameters.map [ it.name.toJavaId ])») throws Throwable {
	  	«IF method.statements.empty»
	  	return null;
	  	«ELSE»
	  	«FOR statement : method.statements.take(method.statements.size-1)»
	  		«statement.compile»		
	  	«ENDFOR»
	  	«IF method.statements.last instanceof Expression»
	  	return « (method.statements.last as Expression).compileForResult»;
	  	«ELSEIF method.statements.last instanceof Return»
	  	«method.statements.last.compile»
	  	«ELSE»
	  	«method.statements.last.compile»
	  	return null;
	  	«ENDIF»
	  	«ENDIF»
	  }
	'''
	def dispatch compile(Attribute declaration) '''
	  private «declaration.classAttribute.compileClassModifier» Object «declaration.name.toJavaId» = «declaration.initialValue.compileForResultOrNull»;
«««	  TODO REMOVER
	  public void set«declaration.name.toJavaIdPart»(Object value) {
	  	this.«declaration.name.toJavaId» = value;
	  }
	  public Object get«declaration.name.toJavaIdPart»() {
	  	return this.«declaration.name.toJavaId»;
	  }
	  public Object «declaration.name.toJavaId»() {
	  	return this.«declaration.name.toJavaId»;
	  }
	'''
	def dispatch compile(Return ret) '''
		return «ret.value.compileForResult»;
	'''
	def dispatch compile(LocalVariable declaration) '''
		Object «declaration.name.toJavaId» = «declaration.getValue.compileForResultOrNull»;
	'''
	def dispatch compile(Applicable pipeline) '''
		«pipeline.left.compile».«pipeline.compileOperation»(«pipeline.right.compile»)
	'''
	def compileOperation(Applicable operation) {
		if(operation.andThen) 'andThen'
		else if(operation.compose) 'compose'
		else if(operation.or) 'or'
		else if(operation.and) 'and'
	}
	def dispatch compile(Message message) '''
		new MessageSend("«message.selector.toJavaId»"
		«IF message.arguments.empty»
		 )
		«ELSE»
		, «joinCompileExpressions(message.arguments)»)
		«ENDIF»
	'''

	
	//Expressions
	def dispatch compile(Expression expression) '''
		«expression.compileForResult»;
	'''
	def dispatch compile(WhenExpression expression) '''
		if («expression.cases.get(0).compileForBooleanResult») {
			«expression.actions.get(0).compile»;
		}
		«IF expression.cases.size > 1»
		«FOR i : 1..expression.cases.size-1»
		else if («expression.cases.get(i).compileForBooleanResult») {
			«expression.actions.get(i).compile»;
		}
		«ENDFOR»
		«ENDIF»
		«IF expression.defaultAction != null»		
		else {
			«expression.defaultAction.compile»;
		}
		«ENDIF»		
	'''
	def dispatch compile(TryCatchExpression expression) '''
		try {
			«expression.action.compile»
		} catch (Throwable e) {
			«expression.catchAction.compile»
		}
	'''
	 
	def dispatch compileForResult(WhenExpression expression) '''
		((«expression.cases.get(0).compileForBooleanResult») ? 
			(«expression.actions.get(0).compileForResult»)
		«IF expression.cases.size > 1»			
		«FOR i : 1..expression.cases.size-1»
		: («expression.cases.get(i).compileForBooleanResult») ?
			(«expression.actions.get(i).compileForResult»)				
		«ENDFOR»
		«ENDIF»
		«IF expression.defaultAction != null»	
		: («expression.defaultAction.compileForResult»)
		«ELSE»
		: null
		«ENDIF»
		)
	'''
	def dispatch compileForResult(ComparisonExpression expression) '''
		«IF expression.op == ComparisonOperation::EQ»
		«expression.left.compileForResult».equals(«expression.right.compileForResult»)
		«ELSEIF expression.op == ComparisonOperation::NEQ»
		!«expression.left.compileForResult».equals(«expression.right.compileForResult»)
		«ELSE»
		((Comparable)(«expression.left.compileForResult»)).compareTo(«expression.right.compileForResult») «expression.op.build»
		«ENDIF»
	'''	
	def build(ComparisonOperation op) {
		switch op {
			case ComparisonOperation::LT: '< 0'
			case ComparisonOperation::GT: '> 0'
			case ComparisonOperation::LTE: '<= 0'
			case ComparisonOperation::GTE: '>= 0'
		}
	}
	
	def dispatch compileForResult(AssignExpression expression) '''
		«expression.target.compileForReference» = («expression.value.compileForResult»)
	'''
	def dispatch compileForResult(IncrementExpression expression) '''
		«expression.target.compileForReference» = new MessageSend(
				"add",
				«expression.value.compileForResultOrOne»
				).apply(«expression.target.compileForReference»)
	'''
	def dispatch compileForResult(DecrementExpression expression) '''
		«expression.target.compileForReference» = new MessageSend(
				"subtract",
				«expression.value.compileForResultOrOne»
				).apply(«expression.target.compileForReference»)
	'''
    def dispatch compileForResult(NumberExpression expression) '''
    	(new java.math.BigDecimal("«expression.value»"))    
    '''
    def dispatch compileForResult(IdExpression expression) {
    	expression.value.compileForReference   
    }
    def dispatch compileForResult(StringExpression expression) '''
    	"«expression.value»"    
    '''
    def dispatch compileForResult(NullExpression expression) '''
    	(null)
    '''
    def dispatch compile(NullExpression expression) '''
    	;
    '''
    def dispatch compileForResult(SelfExpression expression) '''
    	this
    '''      
    def dispatch compileForResult(TrueExpression expression) '''
        true
    '''
    def dispatch compileForResult(FalseExpression expression) '''
        false
    '''
    def dispatch compileForResult(ListLiteralExpression expression) '''
    	new java.util.LinkedList(java.util.Arrays.asList(«joinCompileExpressions(expression.elements)»))
    '''
    def dispatch compileForResult(SetLiteralExpression expression) '''
    	new java.util.HashSet(java.util.Arrays.asList(«joinCompileExpressions(expression.elements)»))
    '''
    def dispatch compileForResult(ThrowExpression expression) '''
    	throw «expression.throwable.compileForResult»
    '''
    def dispatch compileForResult(MessageSendExpression expression) '''
    	«expression.getMessage.compile».apply(«expression.getReceptor.compileForResult»)
    '''
    def dispatch compileForResult(SuperSend expression) '''
    	super.«expression.parentOfType(typeof(Method)).name.toJavaId»(«joinCompileExpressions(expression.arguments)»);
    '''
  def dispatch compileForResult(ForAllExpression expression) '''
		Iterables.each(«expression.target.compileForResult», «expression.action.compile»)
  '''  
  def dispatch compileForResult(SelectExpression expression) {
    compileMapping(expression.target, expression.mapping)
  }
  def dispatch compileForResult(FilteredExpression expression) '''
    Iterables.filter(«expression.target.compileForResult», «expression.condition.compile»)
  '''
  def dispatch compileForResult(ReductionExpression expression) '''
    Iterables.reduce(
    «IF expression.reduction.mapping != null»
     «compileMapping(expression.target, expression.reduction.mapping)»
    «ELSE»
     «expression.target.compileForResult»
    «ENDIF»,
    new «expression.reduction.compile»)
  '''
  def dispatch compile(Reduction reduction) {
  	reduction.subclassResponsibility("compile") as String
  }
  def dispatch compile(Sum reduction) {
  	compileReduction('Sum')
  }
  def dispatch compile(Average reduction) {
  	compileReduction('Average')
  }
  def dispatch compile(Min reduction) {
  	compileReductionWithCriteria('Min', reduction.criteria)
  }
  def dispatch compile(Max reduction) {
  	compileReductionWithCriteria('Max', reduction.criteria)
  }
  def dispatch compile(All reduction) {
    compileReductionWithCriteria('All', reduction.criteria)
  }
  def dispatch compile(Any reduction) {
    compileReductionWithCriteria('Any', reduction.criteria)
  }
	def dispatch compileForResult(NewExpression expression) '''
		new «expression.target.name»(«joinCompileExpressions(expression.arguments)»)
	'''
	def dispatch compileForResult(InitExpression expression) '''
		new «expression.target.name»() {{
			«FOR init : expression.initializations»
				set«init.attribute.toJavaIdPart»(«init.initialValue.compileForResult»);
			«ENDFOR»
		}}
	'''
	def dispatch compileForResult(SetupExpression expression) '''
		«««TODO
	'''	
	
	def dispatch compileForBooleanResult(Expression expression) '''
		(Boolean) («expression.compileForResult»)
	'''
	def dispatch compileForBooleanResult(MessageSendExpression expression) '''
		«expression.message.compile».applyForBoolean(«expression.receptor.compileForResult»)
	'''
	
	def compileForResultOrNull(Expression expression) {
		if (expression != null) expression.compileForResult else "null"  
	}
	
	def compileForResultOrOne(Expression expression) {
		if(expression != null) expression.compileForResult else "java.math.BigDecimal.ONE" 
	}
	
	//TODO pass arguments	
	def compileForResultOrIdentityFunction(Applicable message)'''
		«IF message != null»
			«message.compile»
		«ELSE»
			new IdentityFunction()
		«ENDIF»
	'''
	
	def effectiveSuperType(Type type) { 
		if (type.superType != null) type.superType.name else 'java.lang.Object'
	}
	
	def compileClassModifier(boolean isClassModifier) {
		if (isClassModifier) "static" else ""
	}
	
	def compileReductionWithCriteria(String reductionClass, Applicable criteria) '''
	    «reductionClass»Reduction(«criteria.compileForResultOrIdentityFunction»)
	'''
	 def compileReduction(String reductionClass) '''
      «reductionClass»Reduction()
  '''
  
	
	def dispatch compileForReference(EObject object) {
		object.subclassResponsibility('compileForReference')
	}
	def dispatch compileForReference(Attribute attribute) {
		'this.' + attribute.name.toJavaId
	}	
	def dispatch compileForReference(Parameter parameter) {
		parameter.name.toJavaId
	}	
	def dispatch compileForReference(LocalVariable localVariable) {
		localVariable.name.toJavaId
	}
	def joinCompileExpressions(EList<? extends Expression> expressions) {
    	expressions.map[it.compileForResult].join(',')
    }
  	def joinCompileParameters(Iterable<String> names) {
  		names.map [ "Object " + it ].join(", ")
  	} 
  
  def compileMapping(Expression target, Applicable mapping) '''
    Iterables.map(«target.compileForResult», «mapping.compile»)
  '''      	
    
}
