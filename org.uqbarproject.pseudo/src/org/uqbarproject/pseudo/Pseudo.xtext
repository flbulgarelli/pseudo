grammar org.uqbarproject.pseudo.Pseudo with org.uqbarproject.pseudo.Tokens

/*
 * 
 * no tipado
en espaÃ±ol
preferir texto
filtrar, mapear, todos, ninguno, para cada a nivel lenguaje
listas literales: Conjunto( ), Lista(), Diccionario( clave : valor )
lambdas? 
sin sobrecarga
mixins
constructores alla scala
sin paquetes
orientado a mensajes
composicion de computaciones x LUEGO y
* variables automaticas?
 * 
 */
generate pseudo "http://www.uqbarproject.org/pseudo/Pseudo"

Model:
	types+=Type*;

Type:
	CLASS_TOKEN name=ID (INHERITS_TOKEN superType=[Type])?
	declarations+=Declaration*
	END_TOKEN;

Declaration:
	Attribute | Method;

Method:
	(METHOD_TOKEN | classMethod?=CLASS_METHOD_TOKEN) name=ID ('(' parameters+=ID* ')')?
	statements+=Statement*
	END_TOKEN;

Statement:
	Expression | Return | Let ;

Return:
	RETURN_TOKEN value=EmbeddableExpression;
	
Let:
	LET_TOKEN (name=ID) ('=' (value=Expression))?;

Attribute:
	(ATTRIBUTE_TOKEN|classAttribute?=CLASS_ATTRIBUTE_TOKEN) name=ID ('=' initialValue=Expression)?;

Expression:
	EmbeddableExpression |
	NonEmbeddableExpression;
	
NonEmbeddableExpression:
	SimpleMessageSend |
	TraversableExpression |
	AssignmentExpression |
	IncrementExpression |
	DecrementExpression |
	WhenExpression |
	CollectionLiteralExpression ; //TODO es bastante limitante que no se puedan embeber
	
EmbeddableExpression:
	{IdExpression} value=ID |
	{StringExpression} value=STRING |
	{NumberExpression} value=Number |
	{NullExpression} NULL_TOKEN |
	{TrueExpression} TRUE_TOKEN |
	{FalseExpression} FALSE_TOKEN |
	{SelfExpression} SELF_TOKEN 
//TODO	soportar? '(' NonEmbeddableExpression ')'
	;

Number:
	INT ('.' INT)?;

TraversableExpression:
//TODO ojo que se necesita aplicacion parcial o lambdas
	MaxExpression | //
	MinExpression | //
	AverageExpression | //
	SumExpression | //
	ComprehensionExpression | //
	ForEachExpression
	//	FindExpression |
	//	SortExpression 
;

CollectionLiteralExpression:
	ListLiteralExpression | SetLiteralExpression //| RangeLiteralExpression 
;

ListLiteralExpression:
	{ListLiteralExpression} LIST_OPEN_TOKEN (elements+=EmbeddableExpression)* => LIST_CLOSE_TOKEN	
;

SetLiteralExpression:
	{SetLiteralExpression} SET_OPEN_TOKEN (elements+=EmbeddableExpression)* => SET_CLOSE_TOKEN	
;

RangeLiteralExpression:
	'rango desde' start =  EmbeddableExpression 'hasta' end = EmbeddableExpression 
;


WhenExpression:
	(WHEN_TOKEN (cases+=Expression) 
	THEN_TOKEN actions+= Expression)+ 
	(OTHERWISE_TOKEN defaultAction=Expression)?
	END_TOKEN 
;

SimpleMessageSend:
	receptor = EmbeddableExpression ',' message = Message 
;

Message:
	UnaryMessage //| KeywordMessage
;

UnaryMessage:
	selector=ID //=>(key+=ID argument+=ID)*
;

ComprehensionExpression:
	'generar' (mapping=Message 'de')? target=EmbeddableExpression (=>'tal que' condition=Message)?;

ForEachExpression:
	'para cada' ID 'en' (target=EmbeddableExpression) (=>'tal que' condition=Message)? action=Message;

SumExpression:
	'sumatoria' mapping=Message 'de' target=EmbeddableExpression;

AverageExpression:
	'promedio' mapping=Message 'de' target=EmbeddableExpression;

MaxExpression:
	'maximo entre' target=EmbeddableExpression (=>'segun' condition=Message)?;

MinExpression:
	'minimo entre' target=EmbeddableExpression (=>'segun' condition=Message)?;

AssignmentExpression:
	SET_TOKEN (target=ID) '=' (value=Expression);

IncrementExpression:
	INCREMENT_TOKEN target=ID (ACCUMULATE_BY_TOKEN value = EmbeddableExpression)?
;

DecrementExpression:
	DECREMENT_TOKEN target=ID (ACCUMULATE_BY_TOKEN value = EmbeddableExpression)?
;