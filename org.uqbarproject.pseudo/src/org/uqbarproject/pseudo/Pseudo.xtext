grammar org.uqbarproject.pseudo.Pseudo with org.uqbarproject.pseudo.Tokens

/*
 * 
lambdas? 
mixins
constructores alla scala
sin paquetes
orientado a mensajes
composicion de computaciones x LUEGO y
 * 
 */
generate pseudo "http://www.uqbarproject.org/pseudo/Pseudo"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Model:
	types+=Type*;

Type:
	CLASS_TOKEN name=ID (INHERITS_TOKEN superType=[Type])?
	members+=Member*
	END_TOKEN;

Member:
	Attribute | Method;

Method:
    overrideMethod?=OVERRIDE_TOKEN?	(METHOD_TOKEN | classMethod?=CLASS_METHOD_TOKEN) 
		name=ID 
		=> (OPEN_TOKEN ((parameters+=Parameter) (SEPARATOR_TOKEN parameters+=Parameter)*)?  CLOSE_TOKEN)?
	statements+=Statement*
	END_TOKEN;
	
Parameter:
	name = ID
;	

Statement:
	ExpressionLevel7 | Return | LocalVariable ;

Return:
	RETURN_TOKEN value=ExpressionLevel7;
	
LocalVariable:
	LET_TOKEN (name=ID) ('=' (value=ExpressionLevel7))?;

Attribute:
	(ATTRIBUTE_TOKEN|classAttribute?=CLASS_ATTRIBUTE_TOKEN) name=ID ('=' initialValue=ExpressionLevel7)?;

//Max prioirty
ExpressionLevel7 returns Expression:
	ExpressionLevel6 | 
	AssignExpression | 
	IncrementExpression | 
	DecrementExpression 
;

ExpressionLevel6 returns Expression:
	ComparisonExpression 
;

ExpressionLevel5 returns Expression:
	MessageSendExpression |
	ReductionExpression |
	ForAllExpression |
	ThrowExpression |
	InitExpression |
	SetupExpression |
	WhenExpression |
	TryCatchExpression
;

ExpressionLevel4 returns Expression:
	ExpressionLevel3 |
	SelectExpression 
;

ExpressionLevel3 returns Expression:
	FilteredExpression
;

ExpressionLevel2 returns Expression:
	ExpressionLevel1 |
	NewExpression |
	CollectionLiteralExpression
;

ExpressionLevel1 returns Expression:
	ExpressionLevel0 |
	SuperSend 
;

//Min prioirty
ExpressionLevel0 returns Expression:
	IdExpression |
	StringExpression |
	NumberExpression |
	{NullExpression} NULL_TOKEN |
	{TrueExpression} TRUE_TOKEN |
	{FalseExpression} FALSE_TOKEN |
	{SelfExpression} SELF_TOKEN |
	OPEN_TOKEN ExpressionLevel7  CLOSE_TOKEN
	;
	
IdExpression:
	value=[ecore::EObject]
;	
StringExpression:
	value=STRING
;
	
NumberExpression:
	value=Number
;	

Number:
	INT ('.' INT)?;

MessageSendExpression returns Expression:
	ExpressionLevel4  ({MessageSendExpression.receptor=current} MESSAGE_SEND_TOKEN message=Applicable)* 
;

ComparisonExpression returns Expression:
	ExpressionLevel5 ({ComparisonExpression.left=current} op=ComparisonOperation right=ExpressionLevel5)? 
;

enum ComparisonOperation:
	GT='>' |
	LT='<' |
	GTE= '>=' |
	LTE= '<=' |
	EQ='=' |
	NEQ='/='
;

ForAllExpression:
	FOR_ALL_IN_TOKEN target=ExpressionLevel5 action=Applicable
;

SelectExpression:
	SELECT_TOKEN mapping=Applicable SELECT_FROM_TOKEN target=ExpressionLevel3 
;

ReductionExpression:
	reduction=Reduction REDUCTION_SOURCE_TOKEN target=ExpressionLevel3
;

Reduction:
	{Sum} SUM_TOKEN (OF_TOKEN? mapping=Applicable)?  | 
	{Average} AVERAGE_TOKEN (OF_TOKEN ? mapping=Applicable)? | 
	{Find} FIND_TOKEN (mapping=Applicable)? WHERE_TOKEN criteria=Applicable |
	{Min} MIN_TOKEN (mapping=Applicable)? (COMPARE_BY_TOKEN criteria=Applicable)? | 
	{Max} MAX_TOKEN (mapping=Applicable)? (COMPARE_BY_TOKEN criteria=Applicable)? | 
	{All} ALL_TOKEN (mapping=Applicable)? SATISFY_TOKEN (criteria=Applicable) |
	{Any} ANY_TOKEN (mapping=Applicable)? SATISFY_TOKEN (criteria=Applicable) |
	{First} FIRST_TOKEN (mapping=Applicable)? WHERE_TOKEN (criteria=Applicable)
;

FilteredExpression returns Expression:
	ExpressionLevel2 ({FilteredExpression.target=current} WHERE_TOKEN condition=Applicable)?
;

CollectionLiteralExpression:
	ListLiteralExpression | SetLiteralExpression //| RangeLiteralExpression 
;

ListLiteralExpression:
	{ListLiteralExpression} LIST_OPEN_TOKEN (elements+=ExpressionLevel7 (SEPARATOR_TOKEN elements+=ExpressionLevel7)*)?  LIST_CLOSE_TOKEN	
;

SetLiteralExpression:
	{SetLiteralExpression} SET_OPEN_TOKEN (elements+=ExpressionLevel7 (SEPARATOR_TOKEN elements+=ExpressionLevel7)*)?  SET_CLOSE_TOKEN	
;

//RangeLiteralExpression:
//	'rango desde' start =  EmbeddableExpression 'hasta' end = EmbeddableExpression 
//;


WhenExpression:
	(WHEN_TOKEN (cases+=ExpressionLevel7) 
	THEN_TOKEN actions+= ExpressionLevel7)+ 
	(OTHERWISE_TOKEN defaultAction=ExpressionLevel7)?
	END_TOKEN 
;

TryCatchExpression:
	TRY_TOKEN 
		action= ExpressionLevel7
	CATCH_TOKEN  
		catchAction=ExpressionLevel7	
	END_TOKEN 
;



NewExpression:
	NEW_TOKEN target = [Type] =>(OPEN_TOKEN (arguments+=ExpressionLevel7 (SEPARATOR_TOKEN arguments+=ExpressionLevel7)*)? CLOSE_TOKEN)?
;

InitExpression:
	INIT_TOKEN (NEW_TOKEN)? target=[Type]
	(initializations+=Initialization)+  
	END_TOKEN 	
;

SetupExpression:
	SETUP_TOKEN target=ExpressionLevel7
	(initializations+=Initialization)+  
	END_TOKEN 	
;

Initialization:
	INIT_WITH_TOKEN attribute=ID  '='  initialValue=ExpressionLevel7
;

Applicable returns Applicable:
	Message ({Applicable.left=current} (andThen?=AND_THEN_TOKEN | compose?=COMPOSE_TOKEN | or?=OR_TOKEN | and?=AND_TOKEN) right=Message)*
;


Message returns Applicable:
	{Message} selector=ID =>(OPEN_TOKEN (arguments+=ExpressionLevel7 (SEPARATOR_TOKEN arguments+=ExpressionLevel7)*)? CLOSE_TOKEN)?
;

SuperSend:
	{SuperSend} SUPER_TOKEN =>(OPEN_TOKEN (arguments+=ExpressionLevel7 (SEPARATOR_TOKEN arguments+=ExpressionLevel7)*)? CLOSE_TOKEN)?
;

ThrowExpression:
	(ERROR_TOKEN | THROW_TOKEN) throwable=ExpressionLevel5
;


AssignExpression:
	ASSIGN_TOKEN (target=[ecore::EObject]) '=' value=ExpressionLevel6;
	
IncrementExpression:
	INCREMENT_TOKEN target=[ecore::EObject] (ACCUM_BY_TOKEN value=ExpressionLevel6)?;
	
DecrementExpression:
	DECREMENT_TOKEN target=[ecore::EObject] (ACCUM_BY_TOKEN value=ExpressionLevel6)?;
	
