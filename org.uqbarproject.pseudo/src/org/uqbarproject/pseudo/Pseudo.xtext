grammar org.uqbarproject.pseudo.Pseudo with org.uqbarproject.pseudo.Tokens

generate pseudo "http://www.uqbarproject.org/pseudo/Pseudo"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Model:
	types+=Type*;

Type: ExceptionType | ClassType | ContractType 	;

ExceptionType:
	EXCEPTION_TOKEN name=ID
;

ClassType:
  CLASS_TOKEN name=ID 
  	(INHERITS_TOKEN superType=[Type])?
  	(IMPLEMENTS_TOKEN (contracts+=[ContractType] (SEPARATOR_TOKEN contracts+=[ContractType])*)?)?
    (OPEN_TOKEN (members+=SimpleInstanceAttribute (SEPARATOR_TOKEN members+=SimpleInstanceAttribute)*)? CLOSE_TOKEN)?
	members+=Member*	
	END_TOKEN;
	
ContractType:
  CONTRACT_TOKEN name=ID 
    (INHERITS_TOKEN (contracts+=[ContractType] (SEPARATOR_TOKEN contracts+=[ContractType])*)?)?
	members+=MessageSignature*	
	END_TOKEN;	

Member:
	InstanceAttribute | ClassAttribute | Method;

InstanceAttribute returns Attribute:
	{InstanceAttribute} ATTRIBUTE_TOKEN name=ID ( ':' type=[Type] )? ('=' initialValue=GeneralExpression)?;

ClassAttribute returns Attribute:
	{ClassAttribute} CLASS_ATTRIBUTE_TOKEN name=ID ( ':' type=[Type] )? ('=' initialValue=GeneralExpression)?
;
	
SimpleInstanceAttribute returns Attribute:
  {SimpleInstanceAttribute}	name=ID ( ':' type=[Type] )? ('=' initialValue=GeneralExpression)?
;

MessageSignature:
	MESSAGE_SIGNATURE_TOKEN 
		name=ID 
		=> (OPEN_TOKEN ((parameters+=Parameter) (SEPARATOR_TOKEN parameters+=Parameter)*)?  CLOSE_TOKEN)? 
		( ':' type=[Type] )?
;
	
Method:
    overrideMethod?=OVERRIDE_TOKEN?	(METHOD_TOKEN | classMethod?=CLASS_METHOD_TOKEN) name=ID 
		=> (OPEN_TOKEN ((parameters+=Parameter) (SEPARATOR_TOKEN parameters+=Parameter)*)?  CLOSE_TOKEN)?
		( ':' type=[Type] )?
	statements+=Statement*
	END_TOKEN;
	
Parameter:
	name = ID ( ':' type=[Type] )?
;	

Statement:
	GeneralExpression | Return ;

Return:
	RETURN_TOKEN value=RestrictedExpression;
	
LocalVariable:
	LET_TOKEN (name=ID) ( ':' type=[Type] )? ('=' (value=GeneralExpression))?;

/**
 * Expressions that are either basic, assignment or local variable declarations.
 * They are very general, and thus can appear only in some specific parts of the AST where statements are valid. 
 */
GeneralExpression returns Expression:
	RestrictedExpression |
	AssignExpression | 
	LocalVariable 
;

/** 
 * Restricted expression may appear mostly everywhere where an expression is admitted, 
 * including return statements
 */
RestrictedExpression returns Expression:
	/*descending*/ComparisonExpression | 
	IncrementExpression | 
	DecrementExpression   
;

RestrictedExpressionLevel3 returns Expression:
	/*descending*/ MessageSendExpression |
	ThrowExpression |
	ForEachExpression |
	InitExpression |
	WhenExpression |
	TryCatchExpression
;

RestrictedExpressionLevel2 returns Expression:
	/*descending*/ RestrctedExpressionLevel1 |
	NewExpression |
	CollectionLiteralExpression
;

RestrctedExpressionLevel1 returns Expression:
	/*descending*/ RestrictedExpressionLevel0 |
	SuperSend 
;

//Min prioirty
RestrictedExpressionLevel0 returns Expression:
	IdExpression |
	StringExpression |
	NumberExpression |
	{NullExpression} NULL_TOKEN |
	{TrueExpression} TRUE_TOKEN |
	{FalseExpression} FALSE_TOKEN |
	{SelfExpression} SELF_TOKEN |
	{CatchedExceptionExpression} CATCHED_EXCEPTION_TOKEN |
	OPEN_TOKEN RestrictedExpression  CLOSE_TOKEN
	;
	
IdExpression:
	value=[ecore::EObject]
;	
StringExpression:
	value=STRING
;
	
NumberExpression:
	value=Number
;	

Number:
	INT ('.' INT)?;

MessageSendExpression returns Expression:
	RestrictedExpressionLevel2  ({MessageSendExpression.receptor=current} MESSAGE_SEND_TOKEN message=Message)* 
;

ComparisonExpression returns Expression:
	RestrictedExpressionLevel3 ({ComparisonExpression.left=current} op=ComparisonOperation right=RestrictedExpressionLevel3)? 
;

enum ComparisonOperation:
	GT='>' |
	LT='<' |
	GTE= '>=' |
	LTE= '<=' |
	EQ='=' |
	NEQ='/='
;

ForEachExpression:
	//effectfull action
	{ForEach} FOR_EACH_TOKEN name=ID IN_TOKEN target=RestrictedExpressionLevel3 DO_TOKEN action=RestrictedExpression END_TOKEN |
	//general transform action 
	{Map} MAP_TOKEN name=ID IN_TOKEN target=RestrictedExpressionLevel3 BY_TOKEN action=RestrictedExpression END_TOKEN |
	{Filter} FILTER_TOKEN name=ID IN_TOKEN target=RestrictedExpressionLevel3 BY_TOKEN action=RestrictedExpression END_TOKEN |
	{Sum} SUM_TOKEN name=ID IN_TOKEN target=RestrictedExpressionLevel3 BY_TOKEN action=RestrictedExpression END_TOKEN |
	{Max} MAX_TOKEN name=ID IN_TOKEN target=RestrictedExpressionLevel3 BY_TOKEN action=RestrictedExpression END_TOKEN |
	{Min} MIN_TOKEN name=ID IN_TOKEN target=RestrictedExpressionLevel3 BY_TOKEN action=RestrictedExpression END_TOKEN |
	{Average} AVERAGE_TOKEN name=ID IN_TOKEN target=RestrictedExpressionLevel3 BY_TOKEN action=RestrictedExpression END_TOKEN |
	{Sort} SORT_TOKEN name=ID IN_TOKEN target=RestrictedExpressionLevel3 BY_TOKEN action=RestrictedExpression END_TOKEN |
	//boolean transform action
	{All} ALL_TOKEN name=ID IN_TOKEN target=RestrictedExpressionLevel3 SATISFY_TOKEN action=RestrictedExpression END_TOKEN |
	{Any} ANY_TOKEN name=ID IN_TOKEN target=RestrictedExpressionLevel3 SATISFY_TOKEN action=RestrictedExpression END_TOKEN 
;

CollectionLiteralExpression:
	ListLiteralExpression | SetLiteralExpression  
;

ListLiteralExpression:
	{ListLiteralExpression} LIST_OPEN_TOKEN (elements+=RestrictedExpression (SEPARATOR_TOKEN elements+=RestrictedExpression)*)?  LIST_CLOSE_TOKEN	
;

SetLiteralExpression:
	{SetLiteralExpression} SET_OPEN_TOKEN (elements+=RestrictedExpression (SEPARATOR_TOKEN elements+=RestrictedExpression)*)?  SET_CLOSE_TOKEN	
;

WhenExpression:
	(WHEN_TOKEN (cases+=RestrictedExpression) 
	THEN_TOKEN actions+= RestrictedExpression)+ 
	(OTHERWISE_TOKEN defaultAction=RestrictedExpression)?
	END_TOKEN 
;

TryCatchExpression:
	TRY_TOKEN 
		action= RestrictedExpression
	CATCH_TOKEN  
		catchAction=RestrictedExpression	
	END_TOKEN 
;


NewExpression:
	NEW_TOKEN target = [Type] =>(OPEN_TOKEN (arguments+=RestrictedExpression (SEPARATOR_TOKEN arguments+=RestrictedExpression)*)? CLOSE_TOKEN)?
;

InitExpression:
	INIT_TOKEN (NEW_TOKEN)? target=[Type]
	(initializations+=Initialization)+  
	END_TOKEN 	
;

Initialization:
	INIT_WITH_TOKEN attribute=ID  '='  initialValue=GeneralExpression
;

Message:
	{Message} selector=ID =>(OPEN_TOKEN (arguments+=RestrictedExpression (SEPARATOR_TOKEN arguments+=RestrictedExpression)*)? CLOSE_TOKEN)?
;

SuperSend:
	{SuperSend} SUPER_TOKEN =>(OPEN_TOKEN (arguments+=RestrictedExpression (SEPARATOR_TOKEN arguments+=RestrictedExpression)*)? CLOSE_TOKEN)?
;

ThrowExpression:
  {MessageThrowExpression} ERROR_TOKEN throwable=RestrictedExpressionLevel3 |
  {ExceptionThrowExpression} THROW_TOKEN  throwable=RestrictedExpressionLevel3 
;

AssignExpression:
	ASSIGN_TOKEN (target=[ecore::EObject]) '=' value=RestrictedExpression;
	
IncrementExpression:
	INCREMENT_TOKEN target=[ecore::EObject] (ACCUM_BY_TOKEN value=RestrictedExpression)?;
	
DecrementExpression:
	DECREMENT_TOKEN target=[ecore::EObject] (ACCUM_BY_TOKEN value=RestrictedExpression)?;
	
