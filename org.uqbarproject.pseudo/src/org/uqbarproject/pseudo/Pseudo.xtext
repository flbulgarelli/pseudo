grammar org.uqbarproject.pseudo.Pseudo with org.uqbarproject.pseudo.Tokens

/*
 * 
lambdas? 
mixins
constructores alla scala
sin paquetes
orientado a mensajes
composicion de computaciones x LUEGO y
 * 
 */
generate pseudo "http://www.uqbarproject.org/pseudo/Pseudo"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Model:
	types+=Type*;

Type:
	CLASS_TOKEN name=ID (INHERITS_TOKEN superType=[Type])?
	members+=Member*
	END_TOKEN;

Member:
	Attribute | Method;

Method:
    overrideMethod?=OVERRIDE_TOKEN?	(METHOD_TOKEN | classMethod?=CLASS_METHOD_TOKEN) 
		name=ID 
		(OPEN_TOKEN ((parameters+=Parameter) (SEPARATOR_TOKEN parameters+=Parameter)*)?  =>CLOSE_TOKEN)?
	statements+=Statement*
	END_TOKEN;
	
Parameter:
	name = ID
;	

Statement:
	ExpressionLevel2 | Return | LocalVariable ;

Return:
	RETURN_TOKEN value=ExpressionLevel2;
	
LocalVariable:
	LET_TOKEN (name=ID) ('=' (value=ExpressionLevel2))?;

Attribute:
	(ATTRIBUTE_TOKEN|classAttribute?=CLASS_ATTRIBUTE_TOKEN) name=ID ('=' initialValue=ExpressionLevel2)?;

ExpressionLevel2 returns Expression:
	ExpressionLevel1 |
	MessageSendExpression |
	NewExpression |
	InitExpression |
	SetupExpression |
	TraversableExpression |
	WhenExpression |
	AssignExpression | 
	IncrementExpression | 
	DecrementExpression |
	CollectionLiteralExpression ;

ExpressionLevel1 returns Expression:
	ExpressionLevel0 |
	SuperSend 
;

ExpressionLevel0 returns Expression:
	IdExpression |
	StringExpression |
	NumberExpression |
	{NullExpression} NULL_TOKEN |
	{TrueExpression} TRUE_TOKEN |
	{FalseExpression} FALSE_TOKEN |
	{SelfExpression} SELF_TOKEN //|
//	OPEN_TOKEN ExpressionLevel2 => CLOSE_TOKEN
	;
	
IdExpression:
	value=[ecore::EObject]
;	
StringExpression:
	value=STRING
;
	
NumberExpression:
	value=Number
;	

Number:
	INT ('.' INT)?;

MessageSendExpression returns Expression:
	ExpressionLevel1  ({MessageSendExpression.receptor=current} MESSAGE_SEND_TOKEN message=Applicable)+ 
;

TraversableExpression:
//TODO ojo que se necesita aplicacion parcial o lambdas
	MaxExpression | //
	MinExpression | //
	AverageExpression | //
	SumExpression | //
	ComprehensionExpression | //
	ForEachExpression
	//	FindExpression |
	//	SortExpression 
;

CollectionLiteralExpression:
	ListLiteralExpression | SetLiteralExpression //| RangeLiteralExpression 
;

ListLiteralExpression:
	{ListLiteralExpression} LIST_OPEN_TOKEN (elements+=ExpressionLevel2 (SEPARATOR_TOKEN elements+=ExpressionLevel2)*)? => LIST_CLOSE_TOKEN	
;

SetLiteralExpression:
	{SetLiteralExpression} SET_OPEN_TOKEN (elements+=ExpressionLevel2 (SEPARATOR_TOKEN elements+=ExpressionLevel2)*)? => SET_CLOSE_TOKEN	
;

//RangeLiteralExpression:
//	'rango desde' start =  EmbeddableExpression 'hasta' end = EmbeddableExpression 
//;


WhenExpression:
	(WHEN_TOKEN (cases+=ExpressionLevel2) 
	THEN_TOKEN actions+= ExpressionLevel2)+ 
	(OTHERWISE_TOKEN defaultAction=ExpressionLevel2)?
	END_TOKEN 
;


NewExpression:
	NEW_TOKEN target = [Type] (OPEN_TOKEN (arguments+=ExpressionLevel2 (SEPARATOR_TOKEN arguments+=ExpressionLevel2)*)? => CLOSE_TOKEN)?
;

InitExpression:
	INIT_TOKEN (NEW_TOKEN)? target=[Type]
	(initializations+=Initialization)+  
	END_TOKEN 	
;

SetupExpression:
	SETUP_TOKEN target=ExpressionLevel2
	(initializations+=Initialization)+  
	END_TOKEN 	
;

Initialization:
	INIT_WITH_TOKEN attribute=ID  '='  initialValue=ExpressionLevel2
;


/*Applicatins are limited to not mix operations on purpose */
Applicable:
	Message |
	ApplicablePipeline |
	ApplicableComposition |
	ApplicableDisjuntion |
	ApplicableConjuntion 
;

ApplicablePipeline:
	 messages+=Message (AND_THEN_TOKEN messages+=Message)+
;

ApplicableComposition:
	messages+=Message (COMPOSE_TOKEN messages+=Message)+
;

ApplicableConjuntion:
	messages+=Message (AND_TOKEN messages+=Message)+
;


ApplicableDisjuntion:
	messages+=Message (OR_TOKEN messages+=Message)+
;

Message:
	selector=ID (OPEN_TOKEN (arguments+=ExpressionLevel1 (SEPARATOR_TOKEN arguments+=ExpressionLevel1)*)? => CLOSE_TOKEN)?
;

SuperSend:
	{SuperSend} SUPER_TOKEN (OPEN_TOKEN (arguments+=ExpressionLevel0 (SEPARATOR_TOKEN arguments+=ExpressionLevel0)*)? => CLOSE_TOKEN)?
;

ComprehensionExpression:
	'generar' (mapping=Applicable 'de')? target=ExpressionLevel1 (=>'tal que' condition=Applicable)?;

ForEachExpression:
	'para cada' ID 'en' (target=ExpressionLevel1) (=>'tal que' condition=Applicable)? action=Applicable;

SumExpression:
	'sumatoria' criteria=Applicable 'de' target=ExpressionLevel1;

AverageExpression:
	'promedio' criteria=Applicable 'de' target=ExpressionLevel1;

MaxExpression:
	'maximo entre' target=ExpressionLevel1 (=>'segun' criteria=Applicable)?;

MinExpression:
	'minimo entre' target=ExpressionLevel1 (=>'segun' criteria=Applicable)?;

AssignExpression:
	ASSIGN_TOKEN (target=[ecore::EObject]) '=' value=ExpressionLevel2;
	
IncrementExpression:
	INCREMENT_TOKEN target=[ecore::EObject] (ACCUM_BY_TOKEN value=ExpressionLevel2)?;
	
DecrementExpression:
	DECREMENT_TOKEN target=[ecore::EObject] (ACCUM_BY_TOKEN value=ExpressionLevel2)?;
	
